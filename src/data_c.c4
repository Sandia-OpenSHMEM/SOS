dnl vi: set ft=m4
/* -*- C -*-
 *
 * Copyright 2011 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S.  Government
 * retains certain rights in this software.
 *
 * Copyright (c) 2017 Intel Corporation. All rights reserved.
 * This software is available to you under the BSD license.
 *
 * This file is part of the Sandia OpenSHMEM software package. For license
 * information, see the LICENSE file in the top level directory of the
 * distribution.
 *
 */

/*
 * This is a generated file, do not edit directly.
 */

include(shmem_bind_c.m4)dnl
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define SHMEM_INTERNAL_INCLUDE
#include "shmem.h"
#include "shmemx.h"
#include "shmem_internal.h"
#include "shmem_synchronization.h"
#include "shmem_team.h"

#ifdef ENABLE_PROFILING
#include "pshmem.h"

define(`SHMEM_PROF_DEF_P',
`#pragma weak shmem_$1_p = pshmem_$1_p
#define shmem_$1_p pshmem_$1_p')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_P')

define(`SHMEM_PROF_DEF_CTX_P',
`#pragma weak shmem_ctx_$1_p = pshmem_ctx_$1_p
#define shmem_ctx_$1_p pshmem_ctx_$1_p')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_P')

define(`SHMEM_PROF_DEF_G',
`#pragma weak shmem_$1_g = pshmem_$1_g
#define shmem_$1_g pshmem_$1_g')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_G')

define(`SHMEM_PROF_DEF_CTX_G',
`#pragma weak shmem_ctx_$1_g = pshmem_ctx_$1_g
#define shmem_ctx_$1_g pshmem_ctx_$1_g')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_G')

define(`SHMEM_PROF_DEF_PUT',
`#pragma weak shmem_$1_put = pshmem_$1_put
#define shmem_$1_put pshmem_$1_put')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_PUT')

define(`SHMEM_PROF_DEF_CTX_PUT',
`#pragma weak shmem_ctx_$1_put = pshmem_ctx_$1_put
#define shmem_ctx_$1_put pshmem_ctx_$1_put')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_PUT')

define(`SHMEM_PROF_DEF_PUT_N',
`#pragma weak shmem_put$1 = pshmem_put$1
#define shmem_put$1 pshmem_put$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_PUT_N')
SHMEM_PROF_DEF_PUT_N(`mem')

define(`SHMEM_PROF_DEF_CTX_PUT_N',
`#pragma weak shmem_ctx_put$1 = pshmem_ctx_put$1
#define shmem_ctx_put$1 pshmem_ctx_put$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_PUT_N')
SHMEM_PROF_DEF_CTX_PUT_N(`mem')

define(`SHMEM_PROF_DEF_PUT_NBI',
`#pragma weak shmem_$1_put_nbi = pshmem_$1_put_nbi
#define shmem_$1_put_nbi pshmem_$1_put_nbi')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_PUT_NBI')

define(`SHMEM_PROF_DEF_CTX_PUT_NBI',
`#pragma weak shmem_ctx_$1_put_nbi = pshmem_ctx_$1_put_nbi
#define shmem_ctx_$1_put_nbi pshmem_ctx_$1_put_nbi')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_PUT_NBI')

define(`SHMEM_PROF_DEF_PUT_N_NBI',
`#pragma weak shmem_put$1_nbi = pshmem_put$1_nbi
#define shmem_put$1_nbi pshmem_put$1_nbi')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_PUT_N_NBI')
SHMEM_PROF_DEF_PUT_N_NBI(`mem')

define(`SHMEM_PROF_DEF_CTX_PUT_N_NBI',
`#pragma weak shmem_ctx_put$1_nbi = pshmem_ctx_put$1_nbi
#define shmem_ctx_put$1_nbi pshmem_ctx_put$1_nbi')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_PUT_N_NBI')
SHMEM_PROF_DEF_CTX_PUT_N_NBI(`mem')

define(`SHMEM_PROF_DEF_GET',
`#pragma weak shmem_$1_get = pshmem_$1_get
#define shmem_$1_get pshmem_$1_get')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_GET')

define(`SHMEM_PROF_DEF_CTX_GET',
`#pragma weak shmem_ctx_$1_get = pshmem_ctx_$1_get
#define shmem_ctx_$1_get pshmem_ctx_$1_get')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_GET')

define(`SHMEM_PROF_DEF_GET_N',
`#pragma weak shmem_get$1 = pshmem_get$1
#define shmem_get$1 pshmem_get$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_GET_N')
SHMEM_PROF_DEF_GET_N(`mem')

define(`SHMEM_PROF_DEF_CTX_GET_N',
`#pragma weak shmem_ctx_get$1 = pshmem_ctx_get$1
#define shmem_ctx_get$1 pshmem_ctx_get$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_GET_N')
SHMEM_PROF_DEF_CTX_GET_N(`mem')

define(`SHMEM_PROF_DEF_GET_NBI',
`#pragma weak shmem_$1_get_nbi = pshmem_$1_get_nbi
#define shmem_$1_get_nbi pshmem_$1_get_nbi')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_GET_NBI')

define(`SHMEM_PROF_DEF_CTX_GET_NBI',
`#pragma weak shmem_ctx_$1_get_nbi = pshmem_ctx_$1_get_nbi
#define shmem_ctx_$1_get_nbi pshmem_ctx_$1_get_nbi')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_GET_NBI')

define(`SHMEM_PROF_DEF_GET_N_NBI',
`#pragma weak shmem_get$1_nbi = pshmem_get$1_nbi
#define shmem_get$1_nbi pshmem_get$1_nbi')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_GET_N_NBI')
SHMEM_PROF_DEF_GET_N_NBI(`mem')

define(`SHMEM_PROF_DEF_CTX_GET_N_NBI',
`#pragma weak shmem_ctx_get$1_nbi = pshmem_ctx_get$1_nbi
#define shmem_ctx_get$1_nbi pshmem_ctx_get$1_nbi')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_GET_N_NBI')
SHMEM_PROF_DEF_CTX_GET_N_NBI(`mem')

define(`SHMEM_PROF_DEF_IPUT',
`#pragma weak shmem_$1_iput = pshmem_$1_iput
#define shmem_$1_iput pshmem_$1_iput')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_IPUT')

define(`SHMEM_PROF_DEF_CTX_IPUT',
`#pragma weak shmem_ctx_$1_iput = pshmem_ctx_$1_iput
#define shmem_ctx_$1_iput pshmem_ctx_$1_iput')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_IPUT')

define(`SHMEM_PROF_DEF_IPUT_N',
`#pragma weak shmem_iput$1 = pshmem_iput$1
#define shmem_iput$1 pshmem_iput$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_IPUT_N')

define(`SHMEM_PROF_DEF_CTX_IPUT_N',
`#pragma weak shmem_ctx_iput$1 = pshmem_ctx_iput$1
#define shmem_ctx_iput$1 pshmem_ctx_iput$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_IPUT_N')

define(`SHMEM_PROF_DEF_IBPUT',
`#pragma weak shmemx_$1_ibput = pshmemx_$1_ibput
#define shmemx_$1_ibput pshmemx_$1_ibput')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_IBPUT')

define(`SHMEM_PROF_DEF_CTX_IBPUT',
`#pragma weak shmemx_ctx_$1_ibput = pshmemx_ctx_$1_ibput
#define shmemx_ctx_$1_ibput pshmemx_ctx_$1_ibput')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_IBPUT')

define(`SHMEM_PROF_DEF_IBPUT_N',
`#pragma weak shmemx_ibput$1 = pshmemx_ibput$1
#define shmemx_ibput$1 pshmemx_ibput$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_IBPUT_N')

define(`SHMEM_PROF_DEF_CTX_IBPUT_N',
`#pragma weak shmemx_ctx_ibput$1 = pshmemx_ctx_ibput$1
#define shmemx_ctx_ibput$1 pshmemx_ctx_ibput$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_IBPUT_N')

define(`SHMEM_PROF_DEF_IGET',
`#pragma weak shmem_$1_iget = pshmem_$1_iget
#define shmem_$1_iget pshmem_$1_iget')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_IGET')

define(`SHMEM_PROF_DEF_CTX_IGET',
`#pragma weak shmem_ctx_$1_iget = pshmem_ctx_$1_iget
#define shmem_ctx_$1_iget pshmem_ctx_$1_iget')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_IGET')

define(`SHMEM_PROF_DEF_IGET_N',
`#pragma weak shmem_iget$1 = pshmem_iget$1
#define shmem_iget$1 pshmem_iget$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_IGET_N')

define(`SHMEM_PROF_DEF_CTX_IGET_N',
`#pragma weak shmem_ctx_iget$1 = pshmem_ctx_iget$1
#define shmem_ctx_iget$1 pshmem_ctx_iget$1')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_IGET_N')

/* Blocking put with signal */
define(`SHMEM_PROF_DEF_PUT_SIGNAL',
`#pragma weak shmem_$1_put_signal = pshmem_$1_put_signal
#define shmem_$1_put_signal pshmem_$1_put_signal')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_PUT_SIGNAL')

define(`SHMEM_PROF_DEF_CTX_PUT_SIGNAL',
`#pragma weak shmem_ctx_$1_put_signal = pshmem_ctx_$1_put_signal
#define shmem_ctx_$1_put_signal pshmem_ctx_$1_put_signal')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_PUT_SIGNAL')

define(`SHMEM_PROF_DEF_PUT_N_SIGNAL',
`#pragma weak shmem_put$1_signal = pshmem_put$1_signal
#define shmem_put$1_signal pshmem_put$1_signal')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_PUT_N_SIGNAL')
SHMEM_PROF_DEF_PUT_N_SIGNAL(`mem')

define(`SHMEM_PROF_DEF_CTX_PUT_N_SIGNAL',
`#pragma weak shmem_ctx_put$1_signal = pshmem_ctx_put$1_signal
#define shmem_ctx_put$1_signal pshmem_ctx_put$1_signal')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_PUT_N_SIGNAL')
SHMEM_PROF_DEF_CTX_PUT_N_SIGNAL(`mem')

/* Non-blocking put with signal */
define(`SHMEM_PROF_DEF_PUT_SIGNAL_NBI',
`#pragma weak shmem_$1_put_signal_nbi = pshmem_$1_put_signal_nbi
#define shmem_$1_put_signal_nbi pshmem_$1_put_signal_nbi')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_PUT_SIGNAL_NBI')

define(`SHMEM_PROF_DEF_CTX_PUT_SIGNAL_NBI',
`#pragma weak shmem_ctx_$1_put_signal_nbi = pshmem_ctx_$1_put_signal_nbi
#define shmem_ctx_$1_put_signal_nbi pshmem_ctx_$1_put_signal_nbi')dnl
SHMEM_DEFINE_FOR_RMA(`SHMEM_PROF_DEF_CTX_PUT_SIGNAL_NBI')

define(`SHMEM_PROF_DEF_PUT_N_SIGNAL_NBI',
`#pragma weak shmem_put$1_signal_nbi = pshmem_put$1_signal_nbi
#define shmem_put$1_signal_nbi pshmem_put$1_signal_nbi')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_PUT_N_SIGNAL_NBI')
SHMEM_PROF_DEF_PUT_N_SIGNAL_NBI(`mem')

define(`SHMEM_PROF_DEF_CTX_PUT_N_SIGNAL_NBI',
`#pragma weak shmem_ctx_put$1_signal_nbi = pshmem_ctx_put$1_signal_nbi
#define shmem_ctx_put$1_signal_nbi pshmem_ctx_put$1_signal_nbi')dnl
SHMEM_DEFINE_FOR_SIZES(`SHMEM_PROF_DEF_CTX_PUT_N_SIGNAL_NBI')
SHMEM_PROF_DEF_CTX_PUT_N_SIGNAL_NBI(`mem')

#pragma weak shmemx_putmem_ct = pshmemx_putmem_ct
#define shmemx_putmem_ct pshmemx_putmem_ct
#pragma weak shmemx_getmem_ct = pshmemx_getmem_ct
#define shmemx_getmem_ct pshmemx_getmem_ct
#pragma weak shmemx_ct_create = pshmemx_ct_create
#define shmemx_ct_create pshmemx_ct_create
#pragma weak shmemx_ct_free = pshmemx_ct_free
#define shmemx_ct_free pshmemx_ct_free
#pragma weak shmemx_ct_get = pshmemx_ct_get
#define shmemx_ct_get pshmemx_ct_get
#pragma weak shmemx_ct_set = pshmemx_ct_set
#define shmemx_ct_set pshmemx_ct_set
#pragma weak shmemx_ct_wait = pshmemx_ct_wait
#define shmemx_ct_wait pshmemx_ct_wait
#pragma weak shmem_signal_fetch = pshmem_signal_fetch
#define shmem_signal_fetch pshmem_signal_fetch

#endif /* ENABLE_PROFILING */


#define SHMEM_DEF_P(STYPE,TYPE)                                \
  void SHMEM_FUNCTION_ATTRIBUTES                               \
  SHMEM_FUNC_PROTOTYPE(STYPE##_p, TYPE *addr, TYPE value,      \
                       int pe)                                 \
    SHMEM_ERR_CHECK_INITIALIZED();                             \
    SHMEM_ERR_CHECK_PE(pe);                                    \
    SHMEM_ERR_CHECK_CTX(ctx);                                  \
    SHMEM_ERR_CHECK_SYMMETRIC(addr, sizeof(TYPE));             \
    shmem_internal_put_scalar(ctx, addr, &value, sizeof(TYPE), \
                             pe);                              \
  }

#define SHMEM_DEF_G(STYPE,TYPE)                      \
  TYPE SHMEM_FUNCTION_ATTRIBUTES                     \
  SHMEM_FUNC_PROTOTYPE(STYPE##_g, const TYPE *addr,  \
                       int pe)                       \
    TYPE tmp;                                        \
    SHMEM_ERR_CHECK_INITIALIZED();                   \
    SHMEM_ERR_CHECK_PE(pe);                          \
    SHMEM_ERR_CHECK_CTX(ctx);                        \
    SHMEM_ERR_CHECK_SYMMETRIC(addr, sizeof(TYPE));   \
    shmem_internal_get(ctx, &tmp, addr, sizeof(TYPE),\
                       pe);                          \
    shmem_internal_get_wait(ctx);                    \
    return tmp;                                      \
  }

#define SHMEM_DEF_PUT(STYPE,TYPE)                                \
  void SHMEM_FUNCTION_ATTRIBUTES                                 \
  SHMEM_FUNC_PROTOTYPE(STYPE##_put, TYPE *target,                \
                       const TYPE *source, size_t nelems, int pe)\
    long completion = 0;                                         \
    SHMEM_ERR_CHECK_INITIALIZED();                               \
    SHMEM_ERR_CHECK_PE(pe);                                      \
    SHMEM_ERR_CHECK_CTX(ctx);                                    \
    SHMEM_ERR_CHECK_SYMMETRIC(target, sizeof(TYPE) * nelems);    \
    SHMEM_ERR_CHECK_NULL(source, nelems);                        \
    SHMEM_ERR_CHECK_OVERLAP(target, source, sizeof(TYPE) *       \
                            nelems, sizeof(TYPE) * nelems, 0);   \
    shmem_internal_put_nb(ctx, target, source,                   \
                          sizeof(TYPE) * nelems, pe,             \
                          &completion);                          \
    shmem_internal_put_wait(ctx, &completion);                   \
  }


#define SHMEM_DEF_PUT_N(NAME,SIZE)                             \
  void SHMEM_FUNCTION_ATTRIBUTES                               \
  SHMEM_FUNC_PROTOTYPE(put##NAME, void *target,                \
                       const void *source, size_t nelems,      \
                       int pe)                                 \
    long completion = 0;                                       \
    SHMEM_ERR_CHECK_INITIALIZED();                             \
    SHMEM_ERR_CHECK_PE(pe);                                    \
    SHMEM_ERR_CHECK_CTX(ctx);                                  \
    SHMEM_ERR_CHECK_SYMMETRIC(target, (SIZE) * nelems);        \
    SHMEM_ERR_CHECK_NULL(source, nelems);                      \
    SHMEM_ERR_CHECK_OVERLAP(target, source, (SIZE) * nelems,   \
                            (SIZE) * nelems, 0);               \
    shmem_internal_put_nb(ctx, target, source, (SIZE) * nelems,\
                          pe, &completion);                    \
    shmem_internal_put_wait(ctx, &completion);                 \
  }


#define SHMEM_DEF_PUT_NBI(STYPE,TYPE)                            \
  void SHMEM_FUNCTION_ATTRIBUTES                                 \
  SHMEM_FUNC_PROTOTYPE(STYPE##_put_nbi, TYPE *target,            \
                       const TYPE *source, size_t nelems, int pe)\
    SHMEM_ERR_CHECK_INITIALIZED();                               \
    SHMEM_ERR_CHECK_PE(pe);                                      \
    SHMEM_ERR_CHECK_CTX(ctx);                                    \
    SHMEM_ERR_CHECK_SYMMETRIC(target, sizeof(TYPE) * nelems);    \
    SHMEM_ERR_CHECK_NULL(source, nelems);                        \
    SHMEM_ERR_CHECK_OVERLAP(target, source, sizeof(TYPE) *       \
                            nelems, sizeof(TYPE) * nelems, 0);   \
    shmem_internal_put_nbi(ctx, target, source,                  \
                           sizeof(TYPE)*nelems,                  \
        pe);                                                     \
  }


#define SHMEM_DEF_PUT_N_NBI(NAME,SIZE)                         \
  void SHMEM_FUNCTION_ATTRIBUTES                               \
  SHMEM_FUNC_PROTOTYPE(put##NAME##_nbi, void *target,          \
                       const void *source, size_t nelems,      \
                       int pe)                                 \
    SHMEM_ERR_CHECK_INITIALIZED();                             \
    SHMEM_ERR_CHECK_PE(pe);                                    \
    SHMEM_ERR_CHECK_CTX(ctx);                                  \
    SHMEM_ERR_CHECK_SYMMETRIC(target, (SIZE) * nelems);        \
    SHMEM_ERR_CHECK_NULL(source, nelems);                      \
    SHMEM_ERR_CHECK_OVERLAP(target, source, (SIZE) * nelems,   \
                            (SIZE) * nelems, 0);               \
    shmem_internal_put_nbi(ctx, target, source, (SIZE)*nelems, \
                           pe);                                \
  }


#define SHMEM_DEF_GET(STYPE,TYPE)                             \
  void SHMEM_FUNCTION_ATTRIBUTES                              \
  SHMEM_FUNC_PROTOTYPE(STYPE##_get, TYPE *target,             \
                       const TYPE *source, size_t nelems,     \
                       int pe)                                \
    SHMEM_ERR_CHECK_INITIALIZED();                            \
    SHMEM_ERR_CHECK_PE(pe);                                   \
    SHMEM_ERR_CHECK_CTX(ctx);                                 \
    SHMEM_ERR_CHECK_SYMMETRIC(source, sizeof(TYPE) * nelems); \
    SHMEM_ERR_CHECK_NULL(target, nelems);                     \
    SHMEM_ERR_CHECK_OVERLAP(target, source, sizeof(TYPE) *    \
                            nelems, sizeof(TYPE) * nelems, 0);\
    shmem_internal_get(ctx, target, source,                   \
                       sizeof(TYPE) * nelems, pe);            \
    shmem_internal_get_wait(ctx);                             \
  }


#define SHMEM_DEF_GET_N(NAME,SIZE)                         \
  void SHMEM_FUNCTION_ATTRIBUTES                           \
  SHMEM_FUNC_PROTOTYPE(get##NAME, void *target,            \
                       const void *source, size_t nelems,  \
                       int pe)                             \
    SHMEM_ERR_CHECK_INITIALIZED();                         \
    SHMEM_ERR_CHECK_PE(pe);                                \
    SHMEM_ERR_CHECK_CTX(ctx);                              \
    SHMEM_ERR_CHECK_SYMMETRIC(source, (SIZE) * nelems);    \
    SHMEM_ERR_CHECK_NULL(target, nelems);                  \
    SHMEM_ERR_CHECK_OVERLAP(target, source, (SIZE)*nelems, \
                           (SIZE) * nelems, 0);            \
    shmem_internal_get(ctx, target, source, (SIZE)*nelems, \
                       pe);                                \
    shmem_internal_get_wait(ctx);                          \
  }


#define SHMEM_DEF_GET_NBI(STYPE,TYPE)                            \
  void SHMEM_FUNCTION_ATTRIBUTES                                 \
  SHMEM_FUNC_PROTOTYPE(STYPE##_get_nbi, TYPE *target,            \
                       const TYPE *source,                       \
                       size_t nelems, int pe)                    \
    SHMEM_ERR_CHECK_INITIALIZED();                               \
    SHMEM_ERR_CHECK_PE(pe);                                      \
    SHMEM_ERR_CHECK_CTX(ctx);                                    \
    SHMEM_ERR_CHECK_SYMMETRIC(source, sizeof(TYPE) * nelems);    \
    SHMEM_ERR_CHECK_NULL(target, nelems);                        \
    SHMEM_ERR_CHECK_OVERLAP(target, source, sizeof(TYPE) *       \
                            nelems, sizeof(TYPE) * nelems, 0);   \
    shmem_internal_get(ctx, target, source, sizeof(TYPE)*nelems, \
                       pe);                                      \
  }


#define SHMEM_DEF_GET_N_NBI(NAME,SIZE)                         \
  void SHMEM_FUNCTION_ATTRIBUTES                               \
  SHMEM_FUNC_PROTOTYPE(get##NAME##_nbi, void *target,          \
                       const void *source, size_t nelems,      \
                       int pe)                                 \
    SHMEM_ERR_CHECK_INITIALIZED();                             \
    SHMEM_ERR_CHECK_PE(pe);                                    \
    SHMEM_ERR_CHECK_CTX(ctx);                                  \
    SHMEM_ERR_CHECK_SYMMETRIC(source, (SIZE) * nelems);        \
    SHMEM_ERR_CHECK_NULL(target, nelems);                      \
    SHMEM_ERR_CHECK_OVERLAP(target, source, (SIZE) * nelems,   \
                            (SIZE) * nelems, 0);               \
    shmem_internal_get(ctx, target, source, (SIZE)*nelems, pe);\
  }

#define SHMEM_DEF_IPUT(STYPE,TYPE)                            \
  void SHMEM_FUNCTION_ATTRIBUTES                              \
  SHMEM_FUNC_PROTOTYPE(STYPE##_iput, TYPE *target,            \
                       const TYPE *source, ptrdiff_t tst,     \
                       ptrdiff_t sst, size_t nelems, int pe)  \
    SHMEM_ERR_CHECK_INITIALIZED();                            \
    SHMEM_ERR_CHECK_PE(pe);                                   \
    SHMEM_ERR_CHECK_CTX(ctx);                                 \
    SHMEM_ERR_CHECK_POSITIVE(tst);                            \
    SHMEM_ERR_CHECK_POSITIVE(sst);                            \
    SHMEM_ERR_CHECK_SYMMETRIC(target, sizeof(TYPE) * ((nelems-1) * tst + 1)); \
    SHMEM_ERR_CHECK_NULL(source, nelems);                     \
    SHMEM_ERR_CHECK_OVERLAP(target, source,                   \
                   sizeof(TYPE) * ((nelems-1) * tst + 1),     \
                   sizeof(TYPE) * ((nelems-1) * sst + 1), 0); \
    for ( ; nelems > 0 ; --nelems) {                          \
      shmem_internal_put_scalar(ctx, target, source,          \
                               sizeof(TYPE), pe);             \
      target += tst;                                          \
      source += sst;                                          \
    }                                                         \
  }

#define SHMEM_DEF_IBPUT(STYPE,TYPE)                           \
  void SHMEM_FUNCTION_ATTRIBUTES                              \
  SHMEM_FUNC_PROTOTYPE(STYPE##_ibput, TYPE *target,            \
                       const TYPE *source, ptrdiff_t tst,     \
                       ptrdiff_t sst, size_t bsize, size_t nblocks, int pe)  \
    SHMEM_ERR_CHECK_INITIALIZED();                            \
    SHMEM_ERR_CHECK_PE(pe);                                   \
    SHMEM_ERR_CHECK_CTX(ctx);                                 \
    SHMEM_ERR_CHECK_POSITIVE(tst);                            \
    SHMEM_ERR_CHECK_POSITIVE(sst);                            \
    SHMEM_ERR_CHECK_SYMMETRIC(target, sizeof(TYPE) * ((nblocks-1) * tst + 1)); \
    SHMEM_ERR_CHECK_NULL(source, nblocks);                     \
    SHMEM_ERR_CHECK_OVERLAP(target, source,                   \
                   sizeof(TYPE) * ((nblocks-1) * tst + 1),     \
                   sizeof(TYPE) * ((nblocks-1) * sst + 1), 0); \
    size_t i = 0;                                             \
    for ( ; nblocks > 0 ; --nblocks) {                        \
      for (i = 0; i < bsize; i++) {                           \
        shmem_internal_put_scalar(ctx, target++, source++,    \
                                  sizeof(TYPE), pe);          \
      }                                                       \
      target += (tst-bsize);                                  \
      source += (sst-bsize);                                  \
    }                                                         \
  }

#define SHMEM_DEF_IPUT_N(NAME,SIZE)                          \
  void SHMEM_FUNCTION_ATTRIBUTES                             \
  SHMEM_FUNC_PROTOTYPE(iput##NAME, void *target,             \
                       const void *source, ptrdiff_t tst,    \
                       ptrdiff_t sst, size_t nelems, int pe) \
    SHMEM_ERR_CHECK_INITIALIZED();                           \
    SHMEM_ERR_CHECK_PE(pe);                                  \
    SHMEM_ERR_CHECK_CTX(ctx);                                \
    SHMEM_ERR_CHECK_POSITIVE(tst);                           \
    SHMEM_ERR_CHECK_POSITIVE(sst);                           \
    SHMEM_ERR_CHECK_SYMMETRIC(target,                        \
                           (SIZE) * ((nelems-1) * tst + 1)); \
    SHMEM_ERR_CHECK_NULL(source, nelems);                    \
    SHMEM_ERR_CHECK_OVERLAP(target, source,                  \
                        (SIZE) * ((nelems-1) * tst + 1),     \
                        (SIZE) * ((nelems-1) * sst + 1), 0); \
    for ( ; nelems > 0 ; --nelems) {                         \
      shmem_internal_put_scalar(ctx, target, source, (SIZE), \
                               pe);                          \
      target = (uint8_t*)target + tst*(SIZE);                \
      source = (uint8_t*)source + sst*(SIZE);                \
    }                                                        \
  }

#define SHMEM_DEF_IBPUT_N(NAME,SIZE)                          \
  void SHMEM_FUNCTION_ATTRIBUTES                             \
  SHMEM_FUNC_PROTOTYPE(ibput##NAME, void *target,             \
                       const void *source, ptrdiff_t tst,    \
                       ptrdiff_t sst, size_t bsize, size_t nblocks, int pe) \
    SHMEM_ERR_CHECK_INITIALIZED();                           \
    SHMEM_ERR_CHECK_PE(pe);                                  \
    SHMEM_ERR_CHECK_CTX(ctx);                                \
    SHMEM_ERR_CHECK_POSITIVE(tst);                           \
    SHMEM_ERR_CHECK_POSITIVE(sst);                           \
    SHMEM_ERR_CHECK_SYMMETRIC(target,                        \
                           (SIZE) * ((nblocks-1) * tst + 1)); \
    SHMEM_ERR_CHECK_NULL(source, nelems);                    \
    SHMEM_ERR_CHECK_OVERLAP(target, source,                  \
                        (SIZE) * ((nblocks-1) * tst + 1),     \
                        (SIZE) * ((nblocks-1) * sst + 1), 0); \
    size_t i = 0;                                            \
    for ( ; nblocks > 0 ; --nblocks) {                         \
      for (i = 0; i < bsize; i++) {                          \
        shmem_internal_put_scalar(ctx, target, source, (SIZE), \
                                pe);                          \
        target = (uint8_t*)target + SIZE;                    \
        source = (uint8_t*)source + SIZE;                    \
      }                                                      \
      target = (uint8_t*)target + (tst-bsize)*(SIZE);        \
      source = (uint8_t*)source + (sst-bsize)*(SIZE);        \
    }                                                        \
  }

#define SHMEM_DEF_IGET(STYPE,TYPE)                            \
  void SHMEM_FUNCTION_ATTRIBUTES                              \
  SHMEM_FUNC_PROTOTYPE(STYPE##_iget, TYPE *target,            \
                       const TYPE *source,                    \
                       ptrdiff_t tst, ptrdiff_t sst,          \
                       size_t nelems, int pe)                 \
    SHMEM_ERR_CHECK_INITIALIZED();                            \
    SHMEM_ERR_CHECK_PE(pe);                                   \
    SHMEM_ERR_CHECK_CTX(ctx);                                 \
    SHMEM_ERR_CHECK_POSITIVE(tst);                            \
    SHMEM_ERR_CHECK_POSITIVE(sst);                            \
    SHMEM_ERR_CHECK_SYMMETRIC(source, sizeof(TYPE) * ((nelems-1) * sst + 1)); \
    SHMEM_ERR_CHECK_NULL(target, nelems);                     \
    SHMEM_ERR_CHECK_OVERLAP(target, source,                   \
                   sizeof(TYPE) * ((nelems-1) * tst + 1),     \
                   sizeof(TYPE) * ((nelems-1) * sst + 1), 0); \
    for ( ; nelems > 0 ; --nelems) {                          \
      shmem_internal_get(ctx, target, source, sizeof(TYPE),   \
                         pe);                                 \
      target += tst;                                          \
      source += sst;                                          \
    }                                                         \
    shmem_internal_get_wait(ctx);                             \
  }

#define SHMEM_DEF_IGET_N(NAME,SIZE)                       \
  void SHMEM_FUNCTION_ATTRIBUTES                          \
  SHMEM_FUNC_PROTOTYPE(iget##NAME, void *target,          \
                       const void *source, ptrdiff_t tst, \
                       ptrdiff_t sst, size_t nelems,      \
                       int pe)                            \
    SHMEM_ERR_CHECK_INITIALIZED();                        \
    SHMEM_ERR_CHECK_PE(pe);                               \
    SHMEM_ERR_CHECK_CTX(ctx);                             \
    SHMEM_ERR_CHECK_POSITIVE(tst);                        \
    SHMEM_ERR_CHECK_POSITIVE(sst);                        \
    SHMEM_ERR_CHECK_SYMMETRIC(source,                     \
                        (SIZE) * ((nelems-1) * sst + 1)); \
    SHMEM_ERR_CHECK_NULL(target, nelems);                 \
    SHMEM_ERR_CHECK_OVERLAP(target, source,               \
                     (SIZE) * ((nelems-1) * tst + 1),     \
                     (SIZE) * ((nelems-1) * sst + 1), 0); \
    for ( ; nelems > 0 ; --nelems) {                      \
      shmem_internal_get(ctx, target, source, (SIZE), pe);\
      target = (uint8_t*)target + tst*(SIZE);             \
      source = (uint8_t*)source + sst*(SIZE);             \
    }                                                     \
    shmem_internal_get_wait(ctx);                         \
  }

#define SHMEM_DEF_PUT_SIGNAL(STYPE,TYPE)                                \
  void SHMEM_FUNCTION_ATTRIBUTES                                        \
  SHMEM_FUNC_PROTOTYPE(STYPE##_put_signal, TYPE *target,                \
                        const TYPE *source, size_t nelems,              \
                        uint64_t *sig_addr, uint64_t signal,            \
                        int sig_op, int pe)                             \
    long completion = 0;                                                \
    SHMEM_ERR_CHECK_INITIALIZED();                                      \
    SHMEM_ERR_CHECK_PE(pe);                                             \
    SHMEM_ERR_CHECK_CTX(ctx);                                           \
    SHMEM_ERR_CHECK_SYMMETRIC(target, sizeof(TYPE) * nelems);           \
    SHMEM_ERR_CHECK_NULL(source, nelems);                               \
    SHMEM_ERR_CHECK_OVERLAP(target, sig_addr, sizeof(TYPE) * nelems,    \
                            sizeof(uint64_t), 0);                       \
    SHMEM_ERR_CHECK_SIG_OP(sig_op);                                     \
    shmem_internal_put_nb(ctx, target, source,                          \
                          sizeof(TYPE) * nelems, pe,                    \
                          &completion);                                 \
    shmem_internal_put_wait(ctx, &completion);                          \
    shmem_internal_fence(ctx);                                          \
    if (sig_op == SHMEM_SIGNAL_ADD)                                     \
        shmem_internal_atomic(ctx, sig_addr, &signal, sizeof(uint64_t), \
                              pe, SHM_INTERNAL_SUM,                     \
                              SHM_INTERNAL_UINT64);                     \
    else                                                                \
        shmem_internal_atomic_set(ctx, sig_addr, &signal,               \
                                  sizeof(uint64_t), pe,                 \
                                  SHM_INTERNAL_UINT64);                 \
  }


#define SHMEM_DEF_PUT_N_SIGNAL(NAME,SIZE)                               \
  void SHMEM_FUNCTION_ATTRIBUTES                                        \
  SHMEM_FUNC_PROTOTYPE(put##NAME##_signal, void *target,                \
                        const void *source, size_t nelems,              \
                        uint64_t *sig_addr, uint64_t signal,            \
                        int sig_op, int pe)                             \
    long completion = 0;                                                \
    SHMEM_ERR_CHECK_INITIALIZED();                                      \
    SHMEM_ERR_CHECK_PE(pe);                                             \
    SHMEM_ERR_CHECK_CTX(ctx);                                           \
    SHMEM_ERR_CHECK_SYMMETRIC(target, (SIZE) * nelems);                 \
    SHMEM_ERR_CHECK_NULL(source, nelems);                               \
    SHMEM_ERR_CHECK_OVERLAP(target, sig_addr, (SIZE) * nelems,          \
                            sizeof(uint64_t), 0);                       \
    SHMEM_ERR_CHECK_SIG_OP(sig_op);                                     \
    shmem_internal_put_nb(ctx, target, source, (SIZE) * nelems,         \
                          pe, &completion);                             \
    shmem_internal_put_wait(ctx, &completion);                          \
    shmem_internal_fence(ctx);                                          \
    if (sig_op == SHMEM_SIGNAL_ADD)                                     \
        shmem_internal_atomic(ctx, sig_addr, &signal, sizeof(uint64_t), \
                              pe, SHM_INTERNAL_SUM,                     \
                              SHM_INTERNAL_UINT64);                     \
    else                                                                \
        shmem_internal_atomic_set(ctx, sig_addr, &signal,               \
                                  sizeof(uint64_t), pe,                 \
                                  SHM_INTERNAL_UINT64);                 \
  }

#define SHMEM_DEF_PUT_SIGNAL_NBI(STYPE,TYPE)                            \
  void SHMEM_FUNCTION_ATTRIBUTES                                        \
  SHMEM_FUNC_PROTOTYPE(STYPE##_put_signal_nbi, TYPE *target,            \
                        const TYPE *source, size_t nelems,              \
                        uint64_t *sig_addr, uint64_t signal,            \
                        int sig_op, int pe)                             \
    SHMEM_ERR_CHECK_INITIALIZED();                                      \
    SHMEM_ERR_CHECK_PE(pe);                                             \
    SHMEM_ERR_CHECK_CTX(ctx);                                           \
    SHMEM_ERR_CHECK_SYMMETRIC(target, sizeof(TYPE) * nelems);           \
    SHMEM_ERR_CHECK_NULL(source, nelems);                               \
    SHMEM_ERR_CHECK_OVERLAP(target, sig_addr, sizeof(TYPE) * nelems,    \
                            sizeof(uint64_t), 0);                       \
    SHMEM_ERR_CHECK_SIG_OP(sig_op);                                     \
    shmem_internal_put_signal_nbi(ctx, target, source,                  \
                                  sizeof(TYPE) * nelems, sig_addr,      \
                                  signal, sig_op, pe);                  \
  }


#define SHMEM_DEF_PUT_N_SIGNAL_NBI(NAME,SIZE)                           \
  void SHMEM_FUNCTION_ATTRIBUTES                                        \
  SHMEM_FUNC_PROTOTYPE(put##NAME##_signal_nbi, void *target,            \
                        const void *source, size_t nelems,              \
                        uint64_t *sig_addr, uint64_t signal,            \
                        int sig_op, int pe)                             \
    SHMEM_ERR_CHECK_INITIALIZED();                                      \
    SHMEM_ERR_CHECK_PE(pe);                                             \
    SHMEM_ERR_CHECK_CTX(ctx);                                           \
    SHMEM_ERR_CHECK_SYMMETRIC(target, (SIZE) * nelems);                 \
    SHMEM_ERR_CHECK_NULL(source, nelems);                               \
    SHMEM_ERR_CHECK_OVERLAP(target, sig_addr, (SIZE) * nelems,          \
                            sizeof(uint64_t), 0);                       \
    SHMEM_ERR_CHECK_SIG_OP(sig_op);                                     \
    shmem_internal_put_signal_nbi(ctx, target, source, (SIZE) * nelems, \
                                  sig_addr, signal, sig_op, pe);        \
  }


/* Function prototype for standard routines with the default context: */
#define SHMEM_FUNC_PROTOTYPE(FUNCNAME,  ...)        \
  shmem_##FUNCNAME(__VA_ARGS__) {                   \
  const shmem_ctx_t ctx = SHMEM_CTX_DEFAULT;

#define SHMEMX_FUNC_PROTOTYPE(FUNCNAME,  ...)        \
  shmemx_##FUNCNAME(__VA_ARGS__) {                   \
  const shmem_ctx_t ctx = SHMEM_CTX_DEFAULT;

SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_P')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_G')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N')
SHMEM_DEF_PUT_N(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT_NBI')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N_NBI')
SHMEM_DEF_PUT_N_NBI(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_GET')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_GET_N')
SHMEM_DEF_GET_N(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_GET_NBI')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_GET_N_NBI')
SHMEM_DEF_GET_N_NBI(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_IPUT')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_IPUT_N')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_IBPUT')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_IBPUT_N')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_IGET')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_IGET_N')

SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT_SIGNAL')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N_SIGNAL')
SHMEM_DEF_PUT_N_SIGNAL(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT_SIGNAL_NBI')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N_SIGNAL_NBI')
SHMEM_DEF_PUT_N_SIGNAL_NBI(`mem', `1')

#undef SHMEM_FUNC_PROTOTYPE
#undef SHMEMX_FUNC_PROTOTYPE

#define SHMEM_FUNC_PROTOTYPE(FUNCNAME,  ...)                 \
  shmem_ctx_##FUNCNAME(shmem_ctx_t ctx, __VA_ARGS__) {       \
  pe = shmem_internal_team_pe(((shmem_transport_ctx_t *) ctx)->team, pe);

#define SHMEMX_FUNC_PROTOTYPE(FUNCNAME,  ...)                \
  shmemx_ctx_##FUNCNAME(shmem_ctx_t ctx, __VA_ARGS__) {      \
  pe = shmem_internal_team_pe(((shmem_transport_ctx_t *) ctx)->team, pe);

SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_P')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_G')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N')
SHMEM_DEF_PUT_N(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT_NBI')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N_NBI')
SHMEM_DEF_PUT_N_NBI(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_GET')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_GET_N')
SHMEM_DEF_GET_N(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_GET_NBI')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_GET_N_NBI')
SHMEM_DEF_GET_N_NBI(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_IPUT')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_IPUT_N')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_IBPUT')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_IBPUT_N')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_IGET')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_IGET_N')

SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT_SIGNAL')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N_SIGNAL')
SHMEM_DEF_PUT_N_SIGNAL(`mem', `1')
SHMEM_DEFINE_FOR_RMA(`SHMEM_DEF_PUT_SIGNAL_NBI')
SHMEM_DEFINE_FOR_SIZES(`SHMEM_DEF_PUT_N_SIGNAL_NBI')
SHMEM_DEF_PUT_N_SIGNAL_NBI(`mem', `1')

uint64_t SHMEM_FUNCTION_ATTRIBUTES
shmem_signal_fetch(const uint64_t* sig_addr)
{
    uint64_t val;
    SHMEM_ERR_CHECK_INITIALIZED();
    SHMEM_ERR_CHECK_SYMMETRIC(sig_addr, sizeof(uint64_t));

    shmem_internal_atomic_fetch(SHMEM_CTX_DEFAULT, &val, (void *) sig_addr, 
                                sizeof(uint64_t), shmem_internal_my_pe,
                                SHM_INTERNAL_UINT64);
    shmem_internal_get_wait(SHMEM_CTX_DEFAULT);
    return val;
}

void SHMEM_FUNCTION_ATTRIBUTES
shmemx_getmem_ct(shmemx_ct_t ct, void *target, const void *source, size_t nelems, int pe)
{
    SHMEM_ERR_CHECK_INITIALIZED();
    SHMEM_ERR_CHECK_PE(pe);
    SHMEM_ERR_CHECK_SYMMETRIC(source, nelems);
    SHMEM_ERR_CHECK_NULL(target, nelems);

    shmem_internal_get_ct(ct, target, source, nelems, pe);
    shmem_internal_get_wait(SHMEM_CTX_DEFAULT);
}

void SHMEM_FUNCTION_ATTRIBUTES shmemx_putmem_ct(shmemx_ct_t ct, void *target, const void *source,
                     size_t nelems, int pe)
{
    long completion = 0;

    SHMEM_ERR_CHECK_INITIALIZED();
    SHMEM_ERR_CHECK_PE(pe);
    SHMEM_ERR_CHECK_SYMMETRIC(target, nelems);
    SHMEM_ERR_CHECK_NULL(source, nelems);

    shmem_internal_put_ct_nb(ct, target, source, nelems, pe, &completion);
    shmem_internal_put_wait(SHMEM_CTX_DEFAULT, &completion);
}


void SHMEM_FUNCTION_ATTRIBUTES shmemx_ct_create(shmemx_ct_t *ct)
{
    SHMEM_ERR_CHECK_INITIALIZED();

    shmem_internal_ct_create(ct);
}


void SHMEM_FUNCTION_ATTRIBUTES shmemx_ct_free(shmemx_ct_t *ct)
{
    SHMEM_ERR_CHECK_INITIALIZED();

    shmem_internal_ct_free(ct);
}


long SHMEM_FUNCTION_ATTRIBUTES shmemx_ct_get(shmemx_ct_t ct)
{
    SHMEM_ERR_CHECK_INITIALIZED();

    return shmem_internal_ct_get(ct);
}


void SHMEM_FUNCTION_ATTRIBUTES shmemx_ct_set(shmemx_ct_t ct, long value)
{
    SHMEM_ERR_CHECK_INITIALIZED();

    shmem_internal_ct_set(ct, value);
}


void SHMEM_FUNCTION_ATTRIBUTES shmemx_ct_wait(shmemx_ct_t ct, long wait_for)
{
    SHMEM_ERR_CHECK_INITIALIZED();

    shmem_internal_ct_wait(ct, wait_for);
}
