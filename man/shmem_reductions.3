.TH SHMEM_REDUCTIONS 3 "Open Source Software Solutions, Inc." "OpenSHMEM Library Documentation"
./ sectionStart
.SH NAME
shmem_reductions \- 
The following functions perform reduction operations across all
PEs in a set of PEs.
./ sectionEnd
./ sectionStart
.SH   SYNOPSIS
./ sectionEnd
.SS AND Performs a bitwise AND reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_and\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd

where \TYPE{} is one of the integer types supported for the AND operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_and\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_and\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer types supported for the AND operation and has a corresponding TYPENAME as specified by Table 11.
.SS OR Performs a bitwise OR reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_or\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
where TYPE is one of the integer types supported for the OR operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_or\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_or\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer types supported for the OR operation and has a corresponding TYPENAME as specified by Table 11.
.SS XOR Performs a bitwise XOR reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_xor\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
where TYPE is one of the integer types supported for the XOR operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_xor\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_xor\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer types supported for the XOR operation and has a corresponding TYPENAME as specified by Table 11.
.SS MAX Performs a maximum-value reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_max\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
where TYPE is one of the integer or real types supported for the MAX operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_max\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_max\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer or real types supported for the MAX operation and has a corresponding TYPENAME as specified by Table 11.
.SS MIN Performs a minimum-value reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_min\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
where TYPE is one of the integer or real types supported for the MIN operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_min\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_min\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer or real types supported for the MIN operation and has a corresponding TYPENAME as specified by Table 11.
.SS SUM Performs a sum reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_sum\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
where TYPE is one of the integer, real, or complex types supported for the SUM operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_sum\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_sum\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer, real, or complex types supported for the SUM operation and has a corresponding TYPENAME as specified by Table 11.
.SS PROD Performs a product reduction across a set of PEs.
./ sectionStart
.SS C11:
.B int
.B shmem\_prod\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
where TYPE is one of the integer, real, or complex types supported for the PROD operation as specified by Table 10.
./ sectionStart
.SS C/C++:
./ sectionEnd
./ sectionStart
.B int
.B shmem\_TYPENAME\_prod\_reduce(shmem_team_t
.IB "team" ,
.B TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B size_t
.I nreduce
.B );
./ sectionEnd
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd
./ sectionStart
.B void
.B shmem\_TYPENAME\_prod\_to\_all(TYPE
.IB "*dest" ,
.B const
.B TYPE
.IB "*source" ,
.B int
.IB "nreduce" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B TYPE
.IB "*pWrk" ,
.B long
.I *pSync
.B );
./ sectionEnd
./ sectionStart
.B ****************************************

./ sectionEnd
where TYPE is one of the integer, real, or complex types supported for the PROD operation and has a corresponding TYPENAME as specified by Table 11.
./ sectionStart
.SH DESCRIPTION
.SS Arguments

.BR "IN " -
.I team
- The team over which to perform the operation.%

.BR "OUT " -
.I dest
- Symmetric address of an array, of length 
.I nreduce
elements, to
receive the result of the reduction routines.
The type of 
.I "dest"
should match that implied in the SYNOPSIS section.

.BR "IN " -
.I source
- Symmetric address of an array, of length 
.I nreduce
elements, that
contains one element for each separate reduction routine.
The type of 
.I "source"
should match that implied in the SYNOPSIS section.

.BR "IN " -
.I nreduce
- The number of elements in the 
.I "dest"
and 
.I "source"
arrays. In teams based API calls, 
.I nreduce
must be of type size\_t.
In deprecated active-set based API calls,
.I nreduce
must be of type integer.
./ sectionStart

.B ***************DEPRECATED***************
./ sectionEnd

.BR "IN " -
.I PE\_start
- The lowest PE number of the active set of
PEs.

.BR "IN " -
.I logPE\_stride
- The log (base 2) of the stride between consecutive
PE numbers in the active set.

.BR "IN " -
.I PE\_size
- The number of PEs in the active set.

.BR "IN " -
.I pWrk
- 
Symmetric address of a work array of size at least
max(
.I nreduce
/2 + 1, SHMEM\_REDUCE\_MIN\_WRKDATA\_SIZE)
elements.

.BR "IN " -
.I pSync
- 
Symmetric address of a work array of size at least SHMEM\_REDUCE\_SYNC\_SIZE.
./ sectionStart

.B ****************************************

./ sectionEnd
./ sectionEnd
./ sectionStart
.SS API Description
OpenSHMEM reduction routines are collective routines over an active set or
existing OpenSHMEM team that compute one or more reductions across symmetric
arrays on multiple PEs. A reduction performs an associative binary routine
across a set of values.
The 
.I nreduce
argument determines the number of separate reductions to
perform. The 
.I "source"
array on all PEs participating in the reduction
provides one element for each reduction. The results of the reductions are placed in the
.I "dest"
array on all PEs participating in the reduction.
The 
.I "source"
and 
.I "dest"
arguments must either be the same symmetric
address, or two different symmetric addresses corresponding to buffers that
do not overlap in memory. That is, they must be completely overlapping or
completely disjoint.
Team-based reduction routines operate over all PEs in the provided team argument. All
PEs in the provided team must participate in the reduction.
If 
.I team
compares equal to SHMEM\_TEAM\_INVALID or is
otherwise invalid, the behavior is undefined.
Active-set-based sync routines operate over all PEs in the active set
defined by the 
.I PE\_start
, 
.I logPE\_stride
, 
.I PE\_size
triplet.
As with all active set-based collective routines,
each of these routines assumes
that only PEs in the active set call the routine. If a PE not in
the active set calls an active set-based collective routine,
the behavior is undefined.
The values of arguments 
.I nreduce
, 
.I PE\_start
, 
.I logPE\_stride
,
and 
.I PE\_size
must be equal on all PEs in the active set.
The same 
.I pWrk
and 
.I pSync
work arrays must be passed to all
PEs in the active set.
Before any PE calls a reduction routine, the following conditions must be ensured:
.IP
\(bu The 
.I "dest"
array on all PEs participating in the reduction
is ready to accept the results of the 
.IR "reduction" .
.IP
\(bu If using active-set-based routines, the
.I pWrk
and 
.I pSync
arrays on all PEs in the
active set are not still in use from a prior call to a collective
OpenSHMEM routine.
Otherwise, the behavior is undefined.
Upon return from a reduction routine, the following are true for the local
PE:
.IP
\(bu The 
.I "dest"
array is updated and the 
.I "source"
array may be safely reused.
.IP
\(bu If using active-set-based routines,
the values in the 
.I pSync
array are restored to the original values.
.P
The complex-typed interfaces are only provided for sum and product reductions.
When the C translation environment does not support complex types
(That is, under C language standards prior to C99 or under C11
when \_\_STDC\_NO\_COMPLEX\_\_ is defined to 1), an OpenSHMEM
implementation is not required to provide support for these
complex-typed interfaces.
./ sectionEnd
./ sectionStart
.SS Return Values
Zero on successful local completion. Nonzero otherwise.
./ sectionEnd
./ sectionStart
.SS Examples
In the following C11 example, each PE intializes an array of
random integers with values between $0$ and $npes-1$, inclusively. An OR
reduction then tracks the array indices where maximal values occur (maximal
values equal $npes - 1$), and a SUM reduction counts the total number of
maximal values across all PEs.
.nf
#include <shmem.h>
#include <stdio.h>
#include <stdlib.h>

#define NELEMS 32

int main(void) {
 shmem_init();
 int mype = shmem_my_pe();
 int npes = shmem_n_pes();

 int *values = shmem_malloc(NELEMS * sizeof(int));

 unsigned char *value_is_maximal     = shmem_malloc(NELEMS * sizeof(unsigned char));
 unsigned char *value_is_maximal_all = shmem_malloc(NELEMS * sizeof(unsigned char));

 static int maximal_values_count = 0;
 static int maximal_values_total;

 srand((unsigned)mype);

 for (int i = 0; i < NELEMS; i++) {
   values[i] = rand() % npes;

   /* Track and count instances of maximal values (i.e., values equal to (npes-1)) */
   value_is_maximal[i] = (values[i] == (npes - 1)) ? 1 : 0;
   maximal_values_count += value_is_maximal[i];
 }

 /* Wait for all PEs to initialize reductions arrays */
 shmem_sync(SHMEM_TEAM_WORLD);

 shmem_or_reduce(SHMEM_TEAM_WORLD, value_is_maximal_all, value_is_maximal, NELEMS);
 shmem_sum_reduce(SHMEM_TEAM_WORLD, &maximal_values_total, &maximal_values_count, 1);

 if (mype == 0) {
   printf("Found %d maximal random numbers across all PEs.\\n", maximal_values_total);
   printf("A maximal number occured (at least once) at the following indices:\\n");
   for (int i = 0; i < NELEMS; i++) {
     if (value_is_maximal_all[i] == 1) {
       printf("%d ", i);
     }
   }
   printf("\\n");
 }

 shmem_finalize();
 return 0;
}
.fi
.SS Table 10
Reduction Types, Names, and Supporting Operations for Team-Based Reductions:
.TP
.B | \TYPE | \TYPENAME | Operations Supporting \TYPE |
.TP
| char | char | MAX, MIN, SUM, PROD |
.TP
| signed char | schar | MAX, MIN, SUM, PROD |
.TP
| short | short | MAX, MIN, SUM, PROD |
.TP
| int | int | MAX, MIN, SUM, PROD |
.TP
| long | long | MAX, MIN, SUM, PROD |
.TP
| long long | longlong | MAX, MIN, SUM, PROD |
.TP
| ptrdiff\_t | ptrdiff | MAX, MIN, SUM, PROD |
.TP
| unsigned char | uchar | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| unsigned short | ushort | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| unsigned int | uint | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| unsigned long | ulong | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| unsigned long long | ulonglong | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| int8\_t | int8 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| int16\_t | int16 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| int32\_t | int32 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| int64\_t | int64 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| uint8\_t | uint8 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| uint16\_t | uint16 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| uint32\_t | uint32 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| uint64\_t | uint64 | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| size\_t | size | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| float | float | MAX, MIN, SUM, PROD |
.TP
| double | double | MAX, MIN, SUM, PROD |
.TP
| long double | longdouble | MAX, MIN, SUM, PROD |
.TP
| double \_Complex | complexd | SUM, PROD |
.TP
| float \_Complex | complexf | SUM, PROD |
.SS Table 11
Reduction Types, Names, and Supporting Operations for Active-Set-Based Reductions:
.TP
.B | \TYPE | \TYPENAME | Operations Supporting \TYPE |
.TP
| short | short | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| int | int | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| long | long | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| long long | longlong | AND, OR, XOR MAX, MIN, SUM, PROD |
.TP
| float | float | MAX, MIN, SUM, PROD |
.TP
| double | double | MAX, MIN, SUM, PROD |
.TP
| long double | longdouble | MAX, MIN, SUM, PROD |
.TP
| double \_Complex | complexd | SUM, PROD |
.TP
| float \_Complex | complexf | SUM, PROD |
