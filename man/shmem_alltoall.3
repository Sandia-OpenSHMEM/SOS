.TH SHMEM_ALLTOALL 3 "Open Source Software Solutions, Inc." "OpenSHMEM Library Documentation"
./ sectionStart
.SH NAME
shmem_alltoall \- 
shmem\_alltoall is a collective routine where each PE exchanges a fixed amount of data with all other PEs in the
active set.

./ sectionEnd


./ sectionStart
.SH   SYNOPSIS
./ sectionEnd

./ sectionStart
.SS C/C++:

.B void
.B shmem\_alltoall32(void
.IB "*dest" ,
.B const
.B void
.IB "*source" ,
.B size_t
.IB "nelems" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B long
.I *pSync
.B );



.B void
.B shmem\_alltoall64(void
.IB "*dest" ,
.B const
.B void
.IB "*source" ,
.B size_t
.IB "nelems" ,
.B int
.IB "PE_start" ,
.B int
.IB "logPE_stride" ,
.B int
.IB "PE_size" ,
.B long
.I *pSync
.B );



./ sectionEnd



./ sectionStart

.B ***************DEPRECATED***************
.SS Fortran:

.nf

.BR "INTEGER " "pSync(SHMEM_ALLTOALL_SYNC_SIZE)"
.BR "INTEGER " "PE_start, logPE_stride, PE_size, nelems"
.BR "CALL " "SHMEM\_ALLTOALL32(dest, source, nelems, PE_start, logPE_stride, PE_size, pSync)"
.BR "CALL " "SHMEM\_ALLTOALL64(dest, source, nelems, PE_start, logPE_stride, PE_size, pSync)"

.fi
.B ****************************************

./ sectionEnd





./ sectionStart

.SH DESCRIPTION
.SS Arguments
.BR "OUT " -
.I dest
- A symmetric data object large enough to receive
the combined total of 
.I nelems
elements from each PE in the
active set.


.BR "IN " -
.I source
- A symmetric data object that contains 
.I nelems
elements of data for each PE in the active set, ordered according to
destination PE.


.BR "IN " -
.I nelems
- The number of elements to exchange for each PE.
.I nelems
must be of type size\_t for  C/C++. When using
Fortran, it must be a default integer value.


.BR "IN " -
.I PE\_start
- The lowest PE number of the active set of
PEs. 
.I PE\_start
must be of type integer. When using Fortran,
it must be a default integer value.


.BR "IN " -
.I logPE\_stride
- The log (base 2) of the stride between
consecutive PE numbers in the active set. 
.I logPE\_stride
must be of
type integer. When using Fortran, it must be a default integer value.


.BR "IN " -
.I PE\_size
- The number of PEs in the active set.
.I PE\_size
must be of type integer. When using Fortran, it must
be a default integer value.


.BR "IN " -
.I pSync
- 
A symmetric work array of size SHMEM\_ALLTOALL\_SYNC\_SIZE.
In  C/C++, 
.I pSync
must be an array of elements of type long.
In Fortran, 
.I pSync
must be an array of elements of default integer type.
Every element of this array must be initialized with the value
SHMEM\_SYNC\_VALUE before any of the PEs in the active set
enter the routine.
./ sectionEnd


./ sectionStart

.SS API Description

The 
.B shmem\_alltoall
routines are collective routines. Each PE
in the active set exchanges 
.I nelems
data elements of size
32 bits (for 
.B shmem\_alltoall32
) or 64 bits (for 
.B shmem\_alltoall64
)
with all other PEs in the set. The data being sent and received are
stored in a contiguous symmetric data object. The total size of each PEs
.I source
object and 
.I dest
object is 
.I nelems
times the size of
an element (32 bits or 64 bits) times 
.IR "PE\_size" .
The 
.I source
object contains 
.I PE\_size
blocks of data (the size of each
block defined by 
.I nelems
) and each block of data is sent to a different PE. 
Given a PE 
.I i
that is the \kth PE in the active set and a PE
.I j
that is the \lth PE in the active set,
PE 
.I i
sends the \lth block of its 
.I source
object to
the \kth block of
the 
.I dest
object of PE 
.IR "j" .


As with all OpenSHMEM collective routines, this routine assumes
that only PEs in the active set call the routine. If a PE not
in the active set calls an OpenSHMEM collective routine,
the behavior is undefined.

The values of arguments 
.I nelems
, 
.I PE\_start
, 
.I logPE\_stride
,
and 
.I PE\_size
must be equal on all PEs in the active set. The same
.I dest
and 
.I source
data objects, and the same 
.I pSync
work
array must be passed to all PEs in the active set.

Before any PE calls a 
.B shmem\_alltoall
routine,
the following conditions must be ensured:

.IP


\(bu The 
.I pSync
array on all PEs in the active set is not
still in use from a prior call to a 
.B shmem\_alltoall
routine.

\(bu The 
.I dest
data object on all PEs in the active set is
ready to accept the 
.B shmem\_alltoall
data.

.RE
Otherwise, the behavior is undefined.

Upon return from a 
.B shmem\_alltoall
routine, the following is true for
the local PE: Its 
.I dest
symmetric data object is completely updated and
the data has been copied out of the 
.I source
data object.
The values in the 
.I pSync
array are restored to the original values.

./ sectionEnd



./ sectionStart

The 
.I "dest"
and 
.I "source"
data objects must conform to certain typing
constraints, which are as follows:

.TP 25
Routine
Data type of 
.I dest
and 
.I source

./ sectionEnd



./ sectionStart
.TP 25
shmem\_alltoall64
64 bits aligned.
./ sectionEnd


./ sectionStart
.TP 25
shmem\_alltoall32
32 bits aligned.
./ sectionEnd


./ sectionStart

.SS Return Values

None.

./ sectionEnd


./ sectionStart

.SS API Notes

This routine restores 
.I pSync
to its original contents. Multiple calls
to OpenSHMEM\ routines that use the same 
.I pSync
array do not require
that 
.I pSync
be reinitialized after the first call.
The user must ensure that the 
.I pSync
array is not being updated by any
PE in the active set while any of the PEs participates in
processing of an OpenSHMEM\ 
.B shmem\_alltoall
routine. Be careful to
avoid these situations: If the 
.I pSync
array is initialized at run time,
some type of synchronization is needed to ensure that all PEs in the
active set have initialized 
.I pSync
before any of them enter an
OpenSHMEM\ routine called with the 
.I pSync
synchronization array. A
.I pSync
array may be reused on a subsequent OpenSHMEM\
.B shmem\_alltoall
routine only if none of the PEs in the
active set are still processing a prior OpenSHMEM\ 
.B shmem\_alltoall
routine call that used the same 
.I pSync
array. In general, this can be
ensured only by doing some type of synchronization.

./ sectionEnd



./ sectionStart
.SS Examples



This example shows a 
.B shmem\_alltoall64
on two long elements among all
PEs.

.nf
#include <stdio.h>
#include <inttypes.h>
#include <shmem.h>

int main(void)
{
  static long pSync[SHMEM_ALLTOALL_SYNC_SIZE];
  for (int i = 0; i < SHMEM_ALLTOALL_SYNC_SIZE; i++)
     pSync[i] = SHMEM_SYNC_VALUE;

  shmem_init();
  int me = shmem_my_pe();
  int npes = shmem_n_pes();

  const int count = 2;
  int64_t* dest = (int64_t*) shmem_malloc(count * npes * sizeof(int64_t));
  int64_t* source = (int64_t*) shmem_malloc(count * npes * sizeof(int64_t));

  /* assign source values */
  for (int pe = 0; pe < npes; pe++) {
     for (int i = 0; i < count; i++) {
        source[(pe * count) + i] = me + pe;
        dest[(pe * count) + i] = 9999;
     }
  }
  /* wait for all PEs to update source/dest */
  shmem_barrier_all();

  /* alltoall on all PES */
  shmem_alltoall64(dest, source, count, 0, 0, npes, pSync);

  /* verify results */
  for (int pe = 0; pe < npes; pe++) {
     for (int i = 0; i < count; i++) {
        if (dest[(pe * count) + i] != pe + me) {
           printf("[%d] ERROR: dest[%d]=%" PRId64 ", should be %d\\n",
              me, (pe * count) + i, dest[(pe * count) + i], pe + me);
          }
      }
  }

  shmem_free(dest);
  shmem_free(source);
  shmem_finalize();
  return 0;
}
.fi






